---
layout: post
title: DFT와 FFT 비교
tags: [FFT, Computer Algorithm]
feature-img: "assets/img/0.post/2024-04-08/chelsea.png"
thumbnail: "assets/img/0.post/2024-04-08/chelsea.png"
categories: ALGORITHM
---

## FFT 와 DFT 성능 분석

알고리즘을 성능분석을 하는데는 여러가지 방법이 있겠지만 그중 **시간복잡도**를 이용해 성능을 분석해 볼 것이다.<br>
앞서 말했듯이 **DFT**는 2중 반복문으로 구성되어있기 때문에 시간 복잡도가 **O(N^2)**가 나오는 반면, <br>
**FFT**는 재귀로 함수를 계속 이분할하여 (**Divide and Conquer**) 시간복잡도가 **O(logN)**이 나오는 것 까지 알게되었다.<br>
**이번엔 직관적인 시간 측정을 통하여 성능이 어느 정도 차이나는지 확인해 볼 것이다.**


**source code**<br>
Python 소스코드 파일첨부 | 음원: NF - The search <br>
**run**<br>

## Data, Moduls Loading and Config

#### Data Loading

```python
import numpy as np 
import pygame as pg # pygame 이용해서 그래프 그림
import wave # 음원 분석 라이브러리
import time # 시간 측정 라이브러리
from FFT import * # 앞서 만든 FFT
from DFT import dft # 앞서 만든 DFT
```
```python
# 음원 불러오기 (음원 파일 같이 첨부)
filename = "search.wav"
```

## Basic Exploration

#### Read its basic properties

```python
# WAV 파일을 'rb'(읽기전용) 모드로 실행
music = wave.open(filename, 'rb')

# 오디오가 모노인지 스테레오인지 확인한다
channels = music.getnchannels()

# 오디오의 샘플당 용량을 확인한다 (1비트 = 8비트, 2바이트 = 16비트)
width = music.getsampwidth()

# 오디오의 초당 샘플 갯수(샘플링 레이트)를 확인한다
rate = music.getframerate()

# 오디오파일의 전체 샘플 수 확인한다
frames = music.getnframes()

# 오디오를 한번에 불러올 샘플 개수 설정한다
chunk_size = 1024
```

**주피터 노트북으로 확인결과** <br>

![image](https://github.com/user-attachments/assets/3b1c1cc2-a2b1-4e1c-bacb-266466ebfc42)

> - 오디오가 **16비트**이다 (output = 2)
> - 오디오가 **스테레오**타입이다 (output = 2)
> - 총 샘플 개수는 44100개이다.

#### The diffence betten Mono and Stereo

WAV 파일에서 **Mono**와 **Stereo** 처리 과정에 중요하다<br>
<br>
> - **Mono** : 좌우 구분 없음 (Channels = **1**)
> - **Stereo** : 왼쪽(L), 오른쪽(R) 2개의 트랙으로 나뉜다 (Channels = **2**)

<br>
ex> mono = [x0, x1, x2, x3, ...] , stereo = [L0, R0, L1, R1, L2, R2, ...] <br>
만약 Stereo일 경우 바로 Fourier Transfrom을 할 경우 정상적인 값이 안나온다 <br>
**따라서 한쪽 채널만 추출해서 처리한다 (x = x[::2])**

## Fourier Transfrom

#### Audio Preeprocsssing

```python
# 10초 분량의 음원만 사용 (처리 오래걸림) 
duration_seconds = 10

# 10초 * 초당 샘플수 를 통해 읽을 샘플량을 저장
frames = rate * duration_seconds

# 10초 분량의 데이터를 읽는다(raw binary) -> 숫자아님
data = music.readframes(frames)

music.close()
```

```python
# 음원이 16비트일 경우 (부호 존재)
if width == 2:
    # 부호의 존재로 인해 부호있는 정수형으로 바꾼다
    audio_data = np.frombuffer(data, dtype=np.int16)

# 음원이 8비트일 경우 (부호 없음)
elif width == 1:
    # 부호가 없기 때문에 부호 없는 정수 (uint8)로 바꾼다
    audio_data = np.frombuffer(data, dtype=np.uint8)
else:
    raise ValueError("파일 값 오류")

# 스테레오 일 경우 한쪽 음원만 사용한다
if channels == 2:
    audio_data = audio_data[::2]  # 2의 배수만 사용

start = time.time()
```

#### Fourier Transform

```python
```
























